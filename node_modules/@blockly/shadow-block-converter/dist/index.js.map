{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/shadow-block-converter/webpack/universalModuleDefinition","webpack://@blockly/shadow-block-converter/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/shadow-block-converter/webpack/bootstrap","webpack://@blockly/shadow-block-converter/webpack/runtime/define property getters","webpack://@blockly/shadow-block-converter/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/shadow-block-converter/webpack/runtime/make namespace object","webpack://@blockly/shadow-block-converter/./src/shadow_block_converter.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Plugin for converting shadow blocks to real ones on edit.\n */\n\nimport * as Blockly from 'blockly/core';\n\nexport interface BlockShadowStateChangeJson\n  extends Blockly.Events.BlockBaseJson {\n  inputIndexInParent: number | null;\n  shadowState: Blockly.serialization.blocks.State;\n}\n\n/**\n * A Blockly event class to revert a block connection's shadow state to the\n * provided state, to be used after attaching a child block that would\n * ordinarily overwrite the connection's shadow state.\n */\nexport class BlockShadowStateChange extends Blockly.Events.BlockBase {\n  /**\n   * The name of the event type for broadcast and listening purposes.\n   */\n  /* eslint-disable @typescript-eslint/naming-convention */\n  static readonly EVENT_TYPE = 'block_shadow_state_change';\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  /**\n   * The index of the connection in the parent block's list of connections. If\n   * null, then the nextConnection will be used instead.\n   */\n  inputIndexInParent: number | null;\n\n  /**\n   * The intended shadow state of the connection.\n   */\n  shadowState: Blockly.serialization.blocks.State;\n\n  /**\n   * The constructor for a new BlockShadowStateChange event.\n   *\n   * @param block The parent of the connection to modify.\n   * @param inputIndexInParent The index of the input associated with the\n   *     connection to modify, if it is associated with one. Otherwise the\n   *     nextConnection will be used.\n   * @param shadowState The intended shadow state of the connection.\n   */\n  constructor(\n    block: Blockly.Block,\n    inputIndexInParent: number | null,\n    shadowState: Blockly.serialization.blocks.State,\n  ) {\n    super(block);\n\n    this.type = BlockShadowStateChange.EVENT_TYPE;\n    this.inputIndexInParent = inputIndexInParent;\n    this.shadowState = shadowState;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   * @override\n   */\n  toJson(): BlockShadowStateChangeJson {\n    const json = super.toJson() as BlockShadowStateChangeJson;\n    json['inputIndexInParent'] = this.inputIndexInParent;\n    json['shadowState'] = this.shadowState;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   *\n   * @param json JSON representation.\n   * @override\n   */\n  static fromJson(\n    json: BlockShadowStateChangeJson,\n    workspace: Blockly.Workspace,\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    event?: any,\n  ): BlockShadowStateChange {\n    const newEvent = super.fromJson(\n      json,\n      workspace,\n      event,\n    ) as BlockShadowStateChange;\n    newEvent.inputIndexInParent = json['inputIndexInParent'];\n    newEvent.shadowState = json['shadowState'];\n    return event;\n  }\n\n  /**\n   * Does this event record any change of state?\n   *\n   * @returns False if something changed.\n   * @override\n   */\n  isNull(): boolean {\n    return false;\n  }\n\n  /**\n   * Run a change event.\n   *\n   * @param forward True if run forward, false if run backward (undo).\n   * @override\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    if (!this.blockId) {\n      throw new Error(\n        'The block ID is undefined. Either pass a block to ' +\n          'the constructor, or call fromJson',\n      );\n    }\n    const block = workspace.getBlockById(this.blockId);\n    if (!block) {\n      throw new Error(\n        'The associated block is undefined. Either pass a ' +\n          'block to the constructor, or call fromJson',\n      );\n    }\n\n    const connections = block.getConnections_(true);\n\n    let connection: Blockly.Connection | null;\n    if (this.inputIndexInParent === null) {\n      connection = block.nextConnection;\n    } else if (\n      typeof this.inputIndexInParent !== 'number' ||\n      this.inputIndexInParent < 0 ||\n      this.inputIndexInParent >= connections.length\n    ) {\n      throw new Error('inputIndexInParent was invalid.');\n    } else {\n      connection = block.inputList[this.inputIndexInParent].connection;\n    }\n    if (connection === null) {\n      throw new Error('No matching connection was found.');\n    }\n\n    if (forward) {\n      connection.setShadowState(this.shadowState || null);\n    }\n\n    // Nothing to be done when run backward, because removing a child block\n    // doesn't overwrite the connection's shadowState and thus doesn't need to\n    // be reverted.\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  BlockShadowStateChange.EVENT_TYPE,\n  BlockShadowStateChange,\n);\n\n/**\n * Convert the provided shadow block into a regular block, along with any parent\n * shadow blocks.\n *\n * The provided block will be deleted, and a new regular block will be created\n * in its place that has new id but is otherwise identical to the shadow block.\n * The parent connection's shadow state will be forcibly preserved, despite the\n * fact that attaching a regular block to the connection ordinarily overwrites\n * the connection's shadow state.\n *\n * @param shadowBlock\n * @returns The newly created regular block with a different id, if one could be\n *     created.\n */\nfunction reifyEditedShadowBlock(shadowBlock: Blockly.Block): Blockly.Block {\n  // Determine how the shadow block is connected to the parent.\n  let parentConnection: Blockly.Connection | null = null;\n  let connectionIsThroughOutputConnection = false;\n  if (shadowBlock.previousConnection?.isConnected()) {\n    parentConnection = shadowBlock.previousConnection.targetConnection;\n  } else if (shadowBlock.outputConnection?.isConnected()) {\n    parentConnection = shadowBlock.outputConnection.targetConnection;\n    connectionIsThroughOutputConnection = true;\n  }\n  if (parentConnection === null) {\n    // We can't change the shadow status of a block with no parent, so just\n    // return the block as-is.\n    return shadowBlock;\n  }\n\n  // Get the parent block, and the index of the connection's input if it is\n  // associated with one.\n  let parentBlock = parentConnection.getSourceBlock();\n  const inputInParent = parentConnection.getParentInput();\n  const inputIndexInParent: number | null = inputInParent\n    ? parentBlock.inputList.indexOf(inputInParent)\n    : null;\n\n  // Recover the state of the shadow block before it was edited. The connection\n  // should still have the original state until a new block is attached to it.\n  const originalShadowState = parentConnection.getShadowState(\n    /* returnCurrent = */ false,\n  );\n\n  // Serialize the current state of the shadow block (after it was edited).\n  const editedBlockState = Blockly.serialization.blocks.save(shadowBlock, {\n    addCoordinates: false,\n    addInputBlocks: true,\n    addNextBlocks: true,\n    doFullSerialization: false,\n  });\n  if (originalShadowState === null || editedBlockState === null) {\n    // The serialized block states are necessary to convert the block. Without\n    // them, just return the block as-is.\n    return shadowBlock;\n  }\n\n  // If the parent block is a shadow, it must be converted first.\n  if (parentBlock.isShadow()) {\n    const newParentBlock = reifyEditedShadowBlock(parentBlock);\n    if (newParentBlock === null) {\n      throw new Error(\n        \"No parent block was created, so we can't recreate the \" +\n          'current block either.',\n      );\n    }\n    parentBlock = newParentBlock;\n\n    // The reference to the connection is obsolete. Find it from the new parent.\n    if (inputIndexInParent === null) {\n      parentConnection = parentBlock.nextConnection;\n    } else if (\n      inputIndexInParent < 0 ||\n      inputIndexInParent >= parentBlock.inputList.length\n    ) {\n      throw new Error('inputIndexInParent is invalid.');\n    } else {\n      parentConnection = parentBlock.inputList[inputIndexInParent].connection;\n    }\n    if (parentConnection === null) {\n      throw new Error(\n        \"Couldn't find the corresponding connection on the new \" +\n          'version of the parent block.',\n      );\n    }\n  }\n\n  // Let Blockly generate a new id for the new regular block. Ideally, we would\n  // let the shadow block and the regular block have the same id, and in\n  // principle that ought to be possible since they don't need to coexist at the\n  // same time. However, we'll need to call setShadowState on the connection\n  // after attaching the regular block to revert any changes made by attaching\n  // the block, and the setShadowState implementation temporarily instantiates\n  // the provided shadow state, which can't have the same id as a block in the\n  // workspace. The new shadow state id won't be compatible with any existing\n  // undo history on the shadow block, such as the block change event that\n  // triggered this whole shadow conversion!\n  editedBlockState.id = undefined;\n\n  // Create a regular version of the shadow block by deserializing its state\n  // independently from the connection.\n  const regularBlock = Blockly.serialization.blocks.append(\n    editedBlockState,\n    parentBlock.workspace,\n    {recordUndo: true},\n  );\n\n  // Attach the regular block to the connection in place of the shadow block.\n  const childConnection = connectionIsThroughOutputConnection\n    ? regularBlock.outputConnection\n    : regularBlock.previousConnection;\n  if (childConnection) {\n    parentConnection.connect(childConnection);\n  }\n\n  const wasSelected =\n    Blockly.common.getSelected() === (shadowBlock as Blockly.BlockSvg);\n\n  // The process of connecting a block overwrites the connection's shadow state,\n  // so revert it.\n  parentConnection.setShadowState(originalShadowState);\n  Blockly.Events.fire(\n    new BlockShadowStateChange(\n      parentBlock,\n      inputIndexInParent,\n      originalShadowState,\n    ),\n  );\n\n  if (wasSelected) {\n    Blockly.common.setSelected(regularBlock as Blockly.BlockSvg);\n  }\n\n  return regularBlock;\n}\n\n/**\n * Add this function to your workspace as a change listener to automatically\n * convert shadow blocks to real blocks whenever the user edits a field on the\n * block, like this:\n *\n * workspace.addChangeListener(shadowBlockConversionChangeListener);\n *\n * Ideally the Blockly.Field.prototype.setValue method should handle this logic,\n * but for the purposes of this plugin it can be a workspace change listener.\n *\n * @param event An event broadcast by the workspace.\n */\nexport function shadowBlockConversionChangeListener(\n  event: Blockly.Events.Abstract,\n) {\n  // Auto-converting shadow blocks to real blocks should happen in response to\n  // new user action events (which get recorded as undo events) but not when\n  // undoing or redoing events (which do not get recorded again).\n  if (!event.recordUndo) {\n    return;\n  }\n\n  // Auto-converting shadow blocks to real blocks should happen in response to\n  // editing a field value, which is recorded as Blockly.Events.BLOCK_CHANGE.\n  if (event.type != Blockly.Events.BLOCK_CHANGE) {\n    return;\n  }\n  const blockEvent = event as Blockly.Events.BlockChange;\n\n  if (!blockEvent.workspaceId || !blockEvent.blockId) {\n    return;\n  }\n  const workspace = Blockly.Workspace.getById(blockEvent.workspaceId);\n  if (!workspace) {\n    return;\n  }\n  const block = workspace.getBlockById(blockEvent.blockId);\n  if (!block) {\n    return;\n  }\n\n  // Blocks that are already real blocks can be ignored.\n  if (!block.isShadow()) {\n    return;\n  }\n\n  // Remember the current event group so that it can be resumed below.\n  const currentGroup = Blockly.Events.getGroup();\n\n  if (blockEvent.group) {\n    // Temporarily use the same group as the initiating event so that\n    // the shadow events get grouped with it for undo purposes.\n    Blockly.Events.setGroup(blockEvent.group);\n  } else {\n    // The initiating event wasn't part of any named group, so the shadow events\n    // can't be grouped with it, but at least they can be grouped with each\n    // other.\n    Blockly.Events.setGroup(true);\n  }\n\n  reifyEditedShadowBlock(block);\n\n  // Revert to the current event group, if any.\n  Blockly.Events.setGroup(currentGroup);\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","BlockShadowStateChange","BlockBase","constructor","block","inputIndexInParent","shadowState","super","type","EVENT_TYPE","toJson","json","fromJson","workspace","event","newEvent","isNull","run","forward","getEventWorkspace_","blockId","Error","getBlockById","connections","getConnections_","connection","nextConnection","length","inputList","setShadowState","reifyEditedShadowBlock","shadowBlock","parentConnection","connectionIsThroughOutputConnection","previousConnection","isConnected","targetConnection","outputConnection","parentBlock","getSourceBlock","inputInParent","getParentInput","indexOf","originalShadowState","getShadowState","editedBlockState","blocks","save","addCoordinates","addInputBlocks","addNextBlocks","doFullSerialization","isShadow","newParentBlock","id","regularBlock","append","recordUndo","childConnection","connect","wasSelected","getSelected","fire","setSelected","shadowBlockConversionChangeListener","BLOCK_CHANGE","blockEvent","workspaceId","getById","currentGroup","getGroup","group","setGroup","register","Type","EVENT"],"sourceRoot":""}