{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/workspace-minimap/webpack/universalModuleDefinition","webpack://@blockly/workspace-minimap/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/workspace-minimap/webpack/bootstrap","webpack://@blockly/workspace-minimap/webpack/runtime/define property getters","webpack://@blockly/workspace-minimap/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/workspace-minimap/webpack/runtime/make namespace object","webpack://@blockly/workspace-minimap/./src/focus_region.ts","webpack://@blockly/workspace-minimap/./src/minimap.ts","webpack://@blockly/workspace-minimap/./src/positioned_minimap.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A class that highlights the user's\n * viewport on the minimap.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\n\nconst blockEvents = new Set([\n  Blockly.Events.VIEWPORT_CHANGE,\n  Blockly.Events.BLOCK_CHANGE,\n  Blockly.Events.BLOCK_CREATE,\n  Blockly.Events.BLOCK_DELETE,\n  Blockly.Events.BLOCK_DRAG,\n  Blockly.Events.BLOCK_MOVE,\n]);\n\nconst borderRadius = 6;\n\n/**\n * A class that highlights the user's viewport on the minimap.\n */\nexport class FocusRegion {\n  private onChangeWrapper: (e: Blockly.Events.Abstract) => void;\n  private svgGroup: SVGElement | null = null;\n  private rect: SVGElement | null = null;\n  private background: SVGElement | null = null;\n  private id: string;\n  private initialized = false;\n\n  /**\n   * Constructor for the focus region.\n   *\n   * @param primaryWorkspace The primary workspaceSvg.\n   * @param minimapWorkspace The minimap workspaceSvg.\n   */\n  constructor(\n    private primaryWorkspace: Blockly.WorkspaceSvg,\n    private minimapWorkspace: Blockly.WorkspaceSvg,\n  ) {\n    this.id = String(Math.random()).substring(2);\n    this.onChangeWrapper = this.onChange.bind(this);\n  }\n\n  /**\n   * Initializes focus region.\n   */\n  init() {\n    // Make the svg group element.\n    this.svgGroup = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.G,\n      {class: 'blockly-focus-region'},\n      null,\n    );\n\n    // Make the mask under the svg group.\n    const mask = Blockly.utils.dom.createSvgElement(\n      new Blockly.utils.Svg('mask'),\n      {id: 'focusRegionMask' + this.id},\n      this.svgGroup,\n    );\n\n    // Make the background under the svg group.\n    this.background = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        width: '100%',\n        height: '100%',\n        mask: 'url(#focusRegionMask' + this.id + ')',\n      },\n      this.svgGroup,\n    );\n\n    // Make the white layer under the svg mask.\n    Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        width: '100%',\n        height: '100%',\n        fill: 'white',\n      },\n      mask,\n    );\n\n    // Make the black layer under the mask.\n    this.rect = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.RECT,\n      {\n        x: 0,\n        y: 0,\n        rx: borderRadius,\n        ry: borderRadius,\n        fill: 'black',\n      },\n      mask,\n    );\n\n    // Add the svg group to the minimap.\n    const parentSvg = this.minimapWorkspace.getParentSvg();\n    if (parentSvg.firstChild) {\n      parentSvg.insertBefore(this.svgGroup, parentSvg.firstChild);\n    } else {\n      parentSvg.appendChild(this.svgGroup);\n    }\n\n    window.addEventListener('resize', () => void this.update());\n    window.addEventListener('load', () => void this.update());\n    this.onChangeWrapper = this.onChange.bind(this);\n    this.primaryWorkspace.addChangeListener(this.onChangeWrapper);\n\n    this.update();\n    this.initialized = true;\n  }\n\n  /**\n   * Disposes of the focus region.\n   * Unlinks from all DOM elements and remove all event listeners\n   * to prevent memory leaks.\n   */\n  dispose() {\n    if (this.onChangeWrapper) {\n      this.primaryWorkspace.removeChangeListener(this.onChangeWrapper);\n      this.onChangeWrapper = () => null;\n    }\n    if (this.svgGroup) {\n      Blockly.utils.dom.removeNode(this.svgGroup);\n    }\n    this.svgGroup = null;\n    this.rect = null;\n    this.background = null;\n    this.initialized = false;\n  }\n\n  /**\n   * Handles events triggered on the primary workspace.\n   *\n   * @param event The event.\n   */\n  private onChange(event: Blockly.Events.Abstract): void {\n    if (blockEvents.has(event.type)) {\n      this.update();\n    }\n  }\n\n  /**\n   * Positions and sizes the highlight on the minimap\n   * based on the primary workspace.\n   */\n  private update(): void {\n    // Get the metrics.\n    const primaryMetrics = this.primaryWorkspace.getMetricsManager();\n    const minimapMetrics = this.minimapWorkspace.getMetricsManager();\n\n    const primaryView = primaryMetrics.getViewMetrics(true);\n    const primaryContent = primaryMetrics.getContentMetrics(true);\n    const minimapContent = minimapMetrics.getContentMetrics();\n    const minimapSvg = minimapMetrics.getSvgMetrics();\n\n    // Return if there is no content.\n    if (primaryContent.width === 0) {\n      return;\n    }\n\n    // Get the workscape to pixel scale on the minimap.\n    const scale =\n      minimapContent.width / minimapMetrics.getContentMetrics(true).width;\n\n    // Get the viewport size on a minimap scale.\n    const width = primaryView.width * scale;\n    const height = primaryView.height * scale;\n\n    // Get the viewport position in relation to the content.\n    let left = (primaryView.left - primaryContent.left) * scale;\n    let top = (primaryView.top - primaryContent.top) * scale;\n\n    // Account for the padding outside the content on the minimap.\n    left += (minimapSvg.width - minimapContent.width) / 2;\n    top += (minimapSvg.height - minimapContent.height) / 2;\n\n    // Set the svg attributes.\n    if (!this.rect) {\n      throw new Error(\n        'The focus region must be initialized (`init`) before calling `update`',\n      );\n    } else {\n      this.rect.setAttribute('transform', `translate(${left},${top})`);\n      this.rect.setAttribute('width', width.toString());\n      this.rect.setAttribute('height', height.toString());\n    }\n  }\n\n  /**\n   * Returns whether focus region is initialized or not.\n   *\n   * @returns True if focus region is initialized else false.\n   */\n  isEnabled(): boolean {\n    return this.initialized;\n  }\n}\n\nBlockly.Css.register(`\n.blockly-focus-region {\n  fill: #e6e6e6;\n}\n`);\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A minimap is a miniature version of your blocks that\n * appears on top of your main workspace. This gives you an overview\n * of what your code looks like, and how it is organized.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\nimport {FocusRegion} from './focus_region';\n\n// Events that should be send over to the minimap from the primary workspace\nconst blockEvents = new Set([\n  Blockly.Events.BLOCK_CHANGE,\n  Blockly.Events.BLOCK_CREATE,\n  Blockly.Events.BLOCK_DELETE,\n  Blockly.Events.BLOCK_DRAG,\n  Blockly.Events.BLOCK_MOVE,\n]);\n\n/**\n * A minimap is a miniature version of your blocks that appears on\n * top of your main workspace. This gives you an overview of what\n * your code looks like, and how it is organized.\n */\nexport class Minimap {\n  protected primaryWorkspace: Blockly.WorkspaceSvg;\n  protected minimapWorkspace: Blockly.WorkspaceSvg | null = null;\n  protected focusRegion: FocusRegion | null = null;\n  protected onMouseMoveWrapper: Blockly.browserEvents.Data | null = null;\n  protected onMouseDownWrapper: Blockly.browserEvents.Data | null = null;\n  protected onMouseUpWrapper: Blockly.browserEvents.Data | null = null;\n  protected minimapWrapper: HTMLDivElement | null = null;\n\n  /**\n   * Constructor for a minimap.\n   *\n   * @param workspace The workspace to mirror.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    this.primaryWorkspace = workspace;\n  }\n\n  /**\n   * Initialize.\n   */\n  init(): void {\n    const primaryInjectParentDiv =\n      this.primaryWorkspace.getInjectionDiv().parentNode;\n\n    if (!primaryInjectParentDiv) {\n      throw new Error(\n        'The workspace must be injected into the page before the minimap can be initalized',\n      );\n    }\n\n    // Create a wrapper div for the minimap injection.\n    this.minimapWrapper = document.createElement('div');\n    this.minimapWrapper.id = 'minimapWrapper' + this.primaryWorkspace.id;\n    this.minimapWrapper.className = 'blockly-minimap';\n\n    // Make the wrapper a sibling to the primary injection div.\n    primaryInjectParentDiv?.appendChild(this.minimapWrapper);\n\n    // Inject the minimap workspace.\n    this.minimapWorkspace = Blockly.inject(this.minimapWrapper.id, {\n      // Inherit the layout of the primary workspace.\n      rtl: this.primaryWorkspace.RTL,\n      // Include the scrollbars so that internal scrolling is enabled and\n      // remove direct interaction with the minimap workspace.\n      move: {\n        scrollbars: true,\n        drag: false,\n        wheel: false,\n      },\n      // Remove the scale bounds of the minimap so that it can\n      // correctly zoomToFit.\n      zoom: {\n        maxScale: Infinity,\n        minScale: 0,\n      },\n      readOnly: true,\n      theme: this.primaryWorkspace.getTheme(),\n      renderer: this.primaryWorkspace.options.renderer,\n    });\n\n    this.minimapWorkspace.scrollbar?.setContainerVisible(false);\n    this.primaryWorkspace.addChangeListener((e) => void this.mirror(e));\n    window.addEventListener('resize', () => {\n      if (this.minimapWorkspace) {\n        this.minimapWorkspace.zoomToFit();\n      }\n    });\n\n    // The mousedown handler needs to take precedent over other mouse handlers\n    // in the workspace, such as the handler that opens comments, which means it\n    // needs to be attached in the capture phase. Blockly's built-in event\n    // binding does not let us use the capture phase so we reimplement it here.\n    const mouseDownFunc = (event: Event) =>\n      this.onClickDown(event as PointerEvent);\n    this.minimapWorkspace.svgGroup_.addEventListener(\n      'pointerdown',\n      mouseDownFunc,\n      /* usecapture */ true,\n    );\n    this.onMouseDownWrapper = [\n      [this.minimapWorkspace.svgGroup_, 'pointerdown', mouseDownFunc],\n    ];\n\n    // The mouseup binds to the parent container div instead of the minimap\n    // because if a drag begins on the minimap and ends outside of it the\n    // mousemove should still unbind.\n    this.onMouseUpWrapper = Blockly.browserEvents.bind(\n      primaryInjectParentDiv,\n      'mouseup',\n      this,\n      this.onClickUp,\n    );\n\n    // Initializes the focus region.\n    this.focusRegion = new FocusRegion(\n      this.primaryWorkspace,\n      this.minimapWorkspace,\n    );\n    this.enableFocusRegion();\n  }\n\n  /**\n   * Disposes the minimap.\n   * Unlinks from all DOM elements and remove all event listeners\n   * to prevent memory leaks.\n   */\n  dispose() {\n    if (this.isFocusEnabled()) {\n      this.disableFocusRegion();\n    }\n    if (this.minimapWorkspace) {\n      this.minimapWorkspace.dispose();\n    }\n    Blockly.utils.dom.removeNode(this.minimapWrapper);\n    if (this.onMouseMoveWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseMoveWrapper);\n    }\n    if (this.onMouseDownWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseDownWrapper);\n    }\n    if (this.onMouseUpWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseUpWrapper);\n    }\n  }\n\n  /**\n   * Creates the mirroring between workspaces. Passes on all desired events\n   * to the minimap from the primary workspace.\n   *\n   * @param event The primary workspace event.\n   */\n  private mirror(event: Blockly.Events.Abstract): void {\n    if (!blockEvents.has(event.type)) {\n      return; // Filter out events.\n    }\n    if (\n      event.type === Blockly.Events.BLOCK_CREATE &&\n      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n      (event as any).xml.tagName === 'shadow'\n    ) {\n      return; // Filter out shadow blocks.\n    }\n    // Run the event in the minimap.\n    const json = event.toJson();\n    if (this.minimapWorkspace) {\n      const duplicate = Blockly.Events.fromJson(json, this.minimapWorkspace);\n      duplicate.run(true);\n    }\n\n    // Resize and center the minimap.\n    // We need to wait for the event to finish rendering to do the zoom.\n    Blockly.renderManagement.finishQueuedRenders().then(() => {\n      if (this.minimapWorkspace) {\n        this.minimapWorkspace.zoomToFit();\n      }\n    });\n  }\n\n  /**\n   * Converts the coorindates from a mouse event on the minimap\n   * into scroll coordinates for the primary viewport.\n   *\n   * @param primaryMetrics The metrics from the primary workspace.\n   * @param minimapMetrics The metrics from the minimap workspace.\n   * @param offsetX The x offset of the mouse event.\n   * @param offsetY The y offset of the mouse event.\n   * @returns (x, y) primary workspace scroll coordinates.\n   */\n  static minimapToPrimaryCoords(\n    primaryMetrics: Blockly.utils.Metrics,\n    minimapMetrics: Blockly.utils.Metrics,\n    offsetX: number,\n    offsetY: number,\n  ): [number, number] {\n    // Gets the coordinate relative to the top left of the minimap content.\n    offsetX -= (minimapMetrics.svgWidth - minimapMetrics.contentWidth) / 2;\n    offsetY -= (minimapMetrics.svgHeight - minimapMetrics.contentHeight) / 2;\n\n    // Scales the coordinate to the primary workspace.\n    const scale = primaryMetrics.contentWidth / minimapMetrics.contentWidth;\n    offsetX *= scale;\n    offsetY *= scale;\n\n    // Gets the coordinate relative to the top left of the primary content.\n    let x = -primaryMetrics.contentLeft - offsetX;\n    let y = -primaryMetrics.contentTop - offsetY;\n\n    // Centers the coordinate in the primary viewport.\n    x += primaryMetrics.viewWidth / 2;\n    y += primaryMetrics.viewHeight / 2;\n\n    return [x, y];\n  }\n\n  /**\n   * Scrolls the primary workspace viewport based on a minimap event.\n   *\n   * @param event The minimap browser event.\n   */\n  private primaryScroll(event: PointerEvent): void {\n    const primaryMetrics = this.primaryWorkspace.getMetrics();\n    if (this.minimapWorkspace) {\n      const minimapMetrics = this.minimapWorkspace.getMetrics();\n      if (primaryMetrics && minimapMetrics) {\n        const [x, y] = Minimap.minimapToPrimaryCoords(\n          primaryMetrics,\n          minimapMetrics,\n          event.offsetX,\n          event.offsetY,\n        );\n        this.primaryWorkspace.scroll(x, y);\n      }\n    }\n  }\n\n  /**\n   * Updates the primary workspace viewport based on a click in the minimap.\n   *\n   * @param event The minimap browser event.\n   */\n  private onClickDown(event: PointerEvent): void {\n    if (this.minimapWorkspace) {\n      // Stop any other click event handlers in the workspace from handling\n      // this event.\n      event.stopImmediatePropagation();\n\n      this.onMouseMoveWrapper = Blockly.browserEvents.bind(\n        this.minimapWorkspace.svgGroup_,\n        'mousemove',\n        this,\n        this.onMouseMove,\n      );\n      this.primaryScroll(event);\n    }\n  }\n\n  /**\n   * Unbinds the minimap mousemove when the mouse is not clicked.\n   */\n  private onClickUp(): void {\n    if (this.onMouseMoveWrapper) {\n      Blockly.browserEvents.unbind(this.onMouseMoveWrapper);\n      this.onMouseMoveWrapper = null;\n    }\n  }\n\n  /**\n   * Updates the primary workspace viewport based on a drag in the minimap.\n   *\n   * @param event The minimap browser event.\n   */\n  private onMouseMove(event: PointerEvent): void {\n    this.primaryScroll(event);\n  }\n\n  /**\n   * Enables the focus region; A highlight of the viewport in the minimap.\n   */\n  enableFocusRegion(): void {\n    if (this.focusRegion) {\n      this.focusRegion.init();\n    }\n  }\n\n  /**\n   * Disables the focus region.\n   */\n  disableFocusRegion(): void {\n    if (this.focusRegion) {\n      this.focusRegion.dispose();\n    }\n  }\n\n  /**\n   * Returns whether the focus region is enabled.\n   *\n   * @returns True if the focus region is enabled.\n   */\n  isFocusEnabled(): boolean {\n    if (this.focusRegion) {\n      return this.focusRegion.isEnabled();\n    }\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A positionable version of the minimap.\n * @author cesarades@google.com (Cesar Ades)\n */\n\nimport * as Blockly from 'blockly/core';\nimport {Minimap} from './minimap';\n\nconst minWidth = 200;\n\n/**\n * A positionable version of minimap that implements IPositionable.\n */\nexport class PositionedMinimap\n  extends Minimap\n  implements Blockly.IPositionable\n{\n  protected margin: number;\n  protected top: number;\n  protected left: number;\n  protected width: number;\n  protected height: number;\n  id: string;\n\n  /**\n   * Constructor for a positionable minimap.\n   *\n   * @param workspace The workspace to mirror.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    super(workspace);\n    this.id = 'minimap';\n    this.margin = 20;\n    this.top = 0;\n    this.left = 0;\n    this.width = 225;\n    this.height = 150;\n  }\n\n  /**\n   * Initialize.\n   */\n  init(): void {\n    super.init();\n    this.primaryWorkspace.getComponentManager().addComponent({\n      component: this,\n      weight: 3,\n      capabilities: [Blockly.ComponentManager.Capability.POSITIONABLE],\n    });\n    this.primaryWorkspace.resize();\n  }\n\n  /**\n   * Returns the bounding rectangle of the UI element in pixel units\n   * relative to the Blockly injection div.\n   *\n   * @returns The componentâ€™s bounding box.\n   */\n  getBoundingRectangle(): Blockly.utils.Rect {\n    return new Blockly.utils.Rect(\n      this.top,\n      this.top + this.height,\n      this.left,\n      this.left + this.width,\n    );\n  }\n\n  /**\n   * Positions the minimap.\n   *\n   * @param metrics The workspace metrics.\n   * @param savedPositions List of rectangles already on the workspace.\n   */\n  position(\n    metrics: Blockly.MetricsManager.UiMetrics,\n    savedPositions: Blockly.utils.Rect[],\n  ): void {\n    this.setSize();\n    this.setPosition(metrics, savedPositions);\n    this.setAttributes();\n  }\n\n  /**\n   * Sizes the minimap.\n   *\n   * @internal\n   */\n  setSize(): void {\n    const viewWidth = this.primaryWorkspace.getMetrics().viewWidth;\n    this.width = Math.max(minWidth, viewWidth / 5);\n    this.height = (this.width * 2) / 3;\n  }\n\n  /**\n   * Calculates the position of the minimap over the primary workspace.\n   *\n   * @param metrics The workspace metrics.\n   * @param savedPositions List of rectangles already on the workspace.\n   * @internal\n   */\n  setPosition(\n    metrics: Blockly.MetricsManager.UiMetrics,\n    savedPositions: Blockly.utils.Rect[],\n  ): void {\n    // Aliases.\n    const workspace = this.primaryWorkspace;\n    const scrollbars = workspace.scrollbar;\n\n    const hasVerticalScrollbars =\n      scrollbars && scrollbars.isVisible() && scrollbars.canScrollVertically();\n    const hasHorizontalScrollbars =\n      scrollbars &&\n      scrollbars.isVisible() &&\n      scrollbars.canScrollHorizontally();\n\n    if (\n      metrics.toolboxMetrics.position === Blockly.TOOLBOX_AT_LEFT ||\n      (workspace.horizontalLayout && !workspace.RTL)\n    ) {\n      // Right edge placement.\n      this.left =\n        metrics.absoluteMetrics.left +\n        metrics.viewMetrics.width -\n        this.width -\n        this.margin;\n      if (hasVerticalScrollbars && !workspace.RTL) {\n        this.left -= Blockly.Scrollbar.scrollbarThickness;\n      }\n    } else {\n      // Left edge placement.\n      this.left = this.margin;\n      if (hasVerticalScrollbars && workspace.RTL) {\n        this.left += Blockly.Scrollbar.scrollbarThickness;\n      }\n    }\n\n    const startAtBottom =\n      metrics.toolboxMetrics.position === Blockly.TOOLBOX_AT_BOTTOM;\n    if (startAtBottom) {\n      // Bottom edge placement.\n      this.top =\n        metrics.absoluteMetrics.top +\n        metrics.viewMetrics.height -\n        this.height -\n        this.margin;\n      if (hasHorizontalScrollbars) {\n        // The horizontal scrollbars are always positioned on the bottom.\n        this.top -= Blockly.Scrollbar.scrollbarThickness;\n      }\n    } else {\n      // Upper edge placement.\n      this.top = metrics.absoluteMetrics.top + this.margin;\n    }\n\n    // Check for collision and bump if needed.\n    let boundingRect = this.getBoundingRectangle();\n    for (let i = 0; i < savedPositions.length; i++) {\n      if (boundingRect.intersects(savedPositions[i])) {\n        if (startAtBottom) {\n          this.top = savedPositions[i].top - this.height - this.margin;\n        } else {\n          this.top = savedPositions[i].bottom + this.margin;\n        }\n        // Recheck other savedPositions.\n        boundingRect = this.getBoundingRectangle();\n        i = -1;\n      }\n    }\n  }\n\n  /**\n   * Sets the CSS attribute for the minimap.\n   */\n  private setAttributes(): void {\n    const injectDiv = this.minimapWorkspace?.getInjectionDiv();\n    if (!injectDiv) {\n      return;\n    }\n    if (injectDiv?.parentElement === null) {\n      return;\n    }\n    const style = injectDiv.parentElement.style;\n    style.zIndex = '2';\n    style.position = 'absolute';\n    style.width = `${this.width}px`;\n    style.height = `${this.height}px`;\n    style.top = `${this.top}px`;\n    style.left = `${this.left}px`;\n    if (this.minimapWorkspace) {\n      Blockly.svgResize(this.minimapWorkspace);\n    }\n  }\n}\n\nBlockly.Css.register(`\n.blockly-minimap {\n  box-shadow: 2px 2px 10px grey;\n}\n`);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","blockEvents","Set","VIEWPORT_CHANGE","BLOCK_CHANGE","BLOCK_CREATE","BLOCK_DELETE","BLOCK_DRAG","BLOCK_MOVE","FocusRegion","constructor","primaryWorkspace","minimapWorkspace","svgGroup","rect","background","initialized","id","String","Math","random","substring","onChangeWrapper","onChange","bind","init","dom","createSvgElement","Svg","G","class","mask","RECT","x","y","width","height","fill","rx","ry","parentSvg","getParentSvg","firstChild","insertBefore","appendChild","window","addEventListener","update","addChangeListener","dispose","removeChangeListener","removeNode","event","has","type","primaryMetrics","getMetricsManager","minimapMetrics","primaryView","getViewMetrics","primaryContent","getContentMetrics","minimapContent","minimapSvg","getSvgMetrics","scale","left","top","Error","setAttribute","toString","isEnabled","register","Minimap","workspace","focusRegion","onMouseMoveWrapper","onMouseDownWrapper","onMouseUpWrapper","minimapWrapper","primaryInjectParentDiv","getInjectionDiv","parentNode","document","createElement","className","rtl","RTL","move","scrollbars","drag","wheel","zoom","maxScale","Infinity","minScale","readOnly","theme","getTheme","renderer","options","scrollbar","setContainerVisible","e","mirror","zoomToFit","mouseDownFunc","onClickDown","svgGroup_","onClickUp","enableFocusRegion","isFocusEnabled","disableFocusRegion","unbind","xml","tagName","json","toJson","fromJson","run","finishQueuedRenders","then","minimapToPrimaryCoords","offsetX","offsetY","svgWidth","contentWidth","svgHeight","contentHeight","contentLeft","contentTop","viewWidth","viewHeight","primaryScroll","getMetrics","scroll","stopImmediatePropagation","onMouseMove","PositionedMinimap","super","margin","getComponentManager","addComponent","component","weight","capabilities","Capability","POSITIONABLE","resize","getBoundingRectangle","Rect","position","metrics","savedPositions","setSize","setPosition","setAttributes","max","hasVerticalScrollbars","isVisible","canScrollVertically","hasHorizontalScrollbars","canScrollHorizontally","toolboxMetrics","horizontalLayout","absoluteMetrics","viewMetrics","scrollbarThickness","startAtBottom","boundingRect","length","intersects","bottom","injectDiv","parentElement","style","zIndex"],"sourceRoot":""}